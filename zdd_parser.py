#!/usr/bin/env python3
"""
ZDD Binary Parser

This module provides functionality to parse binary ZDD files generated by witnessc
and provide a queryable interface for ZDD operations.
"""

import struct
import json
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)


@dataclass
class ZDDStructure:
    """Represents the complete ZDD structure as arrays of arrays"""
    magic_number: int
    arrays: List[List[int]]
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


class ZDDParser:
    """Parser for binary ZDD files containing arrays of arrays with integers"""
    
    def __init__(self, zdd_file_path: Path):
        self.zdd_file_path = Path(zdd_file_path)
        self.structure: Optional[ZDDStructure] = None
        self._raw_data: Optional[bytes] = None
        
    def load(self) -> ZDDStructure:
        """Load and parse the ZDD file"""
        if not self.zdd_file_path.exists():
            raise FileNotFoundError(f"ZDD file not found: {self.zdd_file_path}")
            
        with open(self.zdd_file_path, 'rb') as f:
            self._raw_data = f.read()
            
        return self._parse()
    
    def _parse(self) -> ZDDStructure:
        """Parse the binary data into arrays of arrays"""
        if not self._raw_data:
            raise ValueError("No data loaded. Call load() first.")
            
        # Read magic number (first 4 bytes)
        magic_number = struct.unpack('<I', self._raw_data[:4])[0]
        
        logger.info(f"Parsing ZDD file: {self.zdd_file_path.name}")
        logger.info(f"Magic number: {magic_number} (0x{magic_number:08x})")
        logger.info(f"File size: {len(self._raw_data)} bytes")
        
        # Parse arrays of arrays
        arrays = self._parse_arrays_of_arrays()
        
        # Initialize structure
        structure = ZDDStructure(
            magic_number=magic_number,
            arrays=arrays
        )
        
        logger.info(f"Parsed {len(arrays)} arrays")
        
        self.structure = structure
        return structure
    
    def _parse_arrays_of_arrays(self) -> List[List[int]]:
        """Parse the binary data as arrays of arrays with integers"""
        arrays = []
        offset = 4  # Skip magic number
        
        while offset < len(self._raw_data):
            # Try to read array length (4 bytes)
            if offset + 4 > len(self._raw_data):
                break
                
            try:
                array_length = struct.unpack('<I', self._raw_data[offset:offset+4])[0]
                offset += 4
                
                # Validate array length
                if array_length < 0 or array_length > 10000:  # Reasonable bounds
                    logger.warning(f"Invalid array length {array_length} at offset {offset-4}, stopping")
                    break
                
                # Read array elements (each 4 bytes)
                array_data = []
                for i in range(array_length):
                    if offset + 4 > len(self._raw_data):
                        logger.warning(f"Unexpected end of file while reading array element {i}")
                        break
                    
                    element = struct.unpack('<I', self._raw_data[offset:offset+4])[0]
                    array_data.append(element)
                    offset += 4
                
                arrays.append(array_data)
                logger.debug(f"Parsed array {len(arrays)-1}: {array_data}")
                
            except struct.error as e:
                logger.warning(f"Error parsing array at offset {offset}: {e}")
                break
        
        return arrays
    
    def get_array(self, index: int) -> Optional[List[int]]:
        """Get a specific array by index"""
        if not self.structure:
            raise ValueError("No structure loaded. Call load() first.")
        
        if 0 <= index < len(self.structure.arrays):
            return self.structure.arrays[index]
        return None
    
    def get_all_arrays(self) -> List[List[int]]:
        """Get all arrays in the ZDD"""
        if not self.structure:
            raise ValueError("No structure loaded. Call load() first.")
        return self.structure.arrays.copy()
    
    def get_array_count(self) -> int:
        """Get the number of arrays"""
        if not self.structure:
            raise ValueError("No structure loaded. Call load() first.")
        return len(self.structure.arrays)
    
    def get_all_integers(self) -> List[int]:
        """Get all integers from all arrays"""
        if not self.structure:
            raise ValueError("No structure loaded. Call load() first.")
        
        all_integers = []
        for array in self.structure.arrays:
            all_integers.extend(array)
        
        return all_integers
    
    def get_unique_integers(self) -> List[int]:
        """Get unique integers from all arrays"""
        if not self.structure:
            raise ValueError("No structure loaded. Call load() first.")
        
        unique_integers = set()
        for array in self.structure.arrays:
            unique_integers.update(array)
        
        return sorted(list(unique_integers))
    
    def find_arrays_containing(self, value: int) -> List[int]:
        """Find array indices that contain a specific value"""
        if not self.structure:
            raise ValueError("No structure loaded. Call load() first.")
        
        matching_arrays = []
        for i, array in enumerate(self.structure.arrays):
            if value in array:
                matching_arrays.append(i)
        
        return matching_arrays
    
    def get_array_statistics(self) -> Dict[str, Any]:
        """Get statistics about the arrays"""
        if not self.structure:
            raise ValueError("No structure loaded. Call load() first.")
        
        if not self.structure.arrays:
            return {
                'array_count': 0,
                'total_elements': 0,
                'average_array_length': 0,
                'min_array_length': 0,
                'max_array_length': 0,
                'unique_integers': 0
            }
        
        lengths = [len(array) for array in self.structure.arrays]
        all_integers = self.get_all_integers()
        unique_integers = self.get_unique_integers()
        
        return {
            'array_count': len(self.structure.arrays),
            'total_elements': len(all_integers),
            'average_array_length': sum(lengths) / len(lengths),
            'min_array_length': min(lengths),
            'max_array_length': max(lengths),
            'unique_integers': len(unique_integers),
            'integer_range': (min(unique_integers), max(unique_integers)) if unique_integers else (0, 0)
        }
    
    def export_structure(self, output_file: Optional[Path] = None) -> Path:
        """Export the parsed structure to JSON"""
        if not self.structure:
            raise ValueError("No structure loaded. Call load() first.")
        
        if output_file is None:
            output_file = self.zdd_file_path.with_suffix('.parsed.json')
        
        # Convert structure to serializable format
        export_data = {
            'file_path': str(self.zdd_file_path),
            'magic_number': self.structure.magic_number,
            'array_count': len(self.structure.arrays),
            'arrays': self.structure.arrays,
            'statistics': self.get_array_statistics(),
            'metadata': self.structure.metadata
        }
        
        with open(output_file, 'w') as f:
            json.dump(export_data, f, indent=2)
        
        logger.info(f"Structure exported to: {output_file}")
        return output_file
    
    def print_summary(self) -> None:
        """Print a summary of the parsed ZDD"""
        if not self.structure:
            raise ValueError("No structure loaded. Call load() first.")
        
        print(f"\nðŸ“Š ZDD Summary: {self.zdd_file_path.name}")
        print("=" * 50)
        print(f"Magic Number: {self.structure.magic_number} (0x{self.structure.magic_number:08x})")
        print(f"Array Count: {len(self.structure.arrays)}")
        
        # Print statistics
        stats = self.get_array_statistics()
        print(f"Total Elements: {stats['total_elements']}")
        print(f"Average Array Length: {stats['average_array_length']:.1f}")
        print(f"Array Length Range: {stats['min_array_length']} - {stats['max_array_length']}")
        print(f"Unique Integers: {stats['unique_integers']}")
        if stats['unique_integers'] > 0:
            print(f"Integer Range: {stats['integer_range'][0]} - {stats['integer_range'][1]}")
        
        # Print first few arrays
        if self.structure.arrays:
            print(f"\nðŸ“‹ First 5 Arrays:")
            for i, array in enumerate(self.structure.arrays[:5]):
                print(f"  Array {i}: {array}")
            
            if len(self.structure.arrays) > 5:
                print(f"  ... and {len(self.structure.arrays) - 5} more arrays")
        
        print()


def parse_zdd_file(zdd_file_path: Path) -> ZDDStructure:
    """Convenience function to parse a ZDD file"""
    parser = ZDDParser(zdd_file_path)
    return parser.load()


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) != 2:
        print("Usage: python zdd_parser.py <zdd_file>")
        sys.exit(1)
    
    zdd_file = Path(sys.argv[1])
    if not zdd_file.exists():
        print(f"Error: File not found: {zdd_file}")
        sys.exit(1)
    
    try:
        parser = ZDDParser(zdd_file)
        structure = parser.load()
        parser.print_summary()
        parser.export_structure()
    except Exception as e:
        print(f"Error parsing ZDD file: {e}")
        sys.exit(1) 